<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <link rel="icon" href="/assets/images/logo.png"> <title>Layer-4 Load Balancer & Zero-downtime Autoscaling and Upgrade | Charles Xu</title> <title>Layer-4 Load Balancer &amp; Zero-downtime Autoscaling and Upgrade | Charles Xu</title> <meta name="generator" content="Jekyll v4.2.0"/> <meta property="og:title" content="Layer-4 Load Balancer &amp; Zero-downtime Autoscaling and Upgrade"/> <meta property="og:locale" content="en_US"/> <meta name="description" content="Abstract"/> <meta property="og:description" content="Abstract"/> <meta property="og:site_name" content="Charles Xu"/> <meta property="og:image" content="/assets/images/source-ip-autoscale/cover2.jpeg"/> <meta property="og:type" content="article"/> <meta property="article:published_time" content="2023-08-06T00:00:00-05:00"/> <meta name="twitter:card" content="summary_large_image"/> <meta property="twitter:image" content="/assets/images/source-ip-autoscale/cover2.jpeg"/> <meta property="twitter:title" content="Layer-4 Load Balancer &amp; Zero-downtime Autoscaling and Upgrade"/> <script type="application/ld+json">
{"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/images/logo.png"}},"image":"/assets/images/source-ip-autoscale/cover2.jpeg","headline":"Layer-4 Load Balancer &amp; Zero-downtime Autoscaling and Upgrade","dateModified":"2023-08-06T00:00:00-05:00","datePublished":"2023-08-06T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"/source-ip-autoscale/"},"@type":"BlogPosting","description":"Abstract","url":"/source-ip-autoscale/","@context":"https://schema.org"}</script> <link href="/assets/css/bootstrap.min.css" rel="stylesheet"> <script src="/assets/js/jquery.min.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-8CYZ0N0EWJ"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-8CYZ0N0EWJ");</script> <script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-151349369-1","auto"),ga("send","pageview");</script> <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "5b6e3d4ee3274005a2d3321f9bb0516c"}'></script> </head> <body class="layout-post"> <noscript id="deferred-styles"> <link href="/assets/css/fontawesome.css" rel="stylesheet"> <link href="/assets/css/google-fonts.css" rel="stylesheet"> </noscript> <nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down"> <div class="container pr-0"> <a class="navbar-brand" href="/"> <img src="/assets/images/logo.png" alt="Charles Xu" height="32" width="32"> </a> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <div class="collapse navbar-collapse" id="navbarMediumish"> <ul class="navbar-nav ml-auto"> <li class="nav-item"> <a class="nav-link" href="/about">About</a> </li> <li class="nav-item"> <a class="nav-link" href="/bookshelf">Bookshelf</a> </li> <li class="nav-item"> <a class="nav-link" href="/inspirations">Inspirations</a> </li> <li class="nav-item"> <a class="nav-link" href="/wiki">Wiki</a> </li> <li class="nav-item"> <a class="nav-link" href="/">Blog</a> </li> <script src="/assets/js/lunr.js"></script> <style>.lunrsearchresult .title{color:#d9230f}.lunrsearchresult .url{color:silver}.lunrsearchresult a{display:block;color:#777}.lunrsearchresult a:hover,.lunrsearchresult a:focus{text-decoration:none}.lunrsearchresult a:hover .title{text-decoration:underline}</style> <div style="width: 14px; height: 10px;"></div> <form class="bd-search" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);"> <input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/> </form> <div id="lunrsearchresults"> <ul></ul> </div> <script src="/assets/js/lunrsearchengine.js"></script> </ul> </div> </div> </nav> <div class="site-content"> <div class="container"> <div class="mainheading"> <h1 class="sitetitle">Charles Xu</h1> <p class="lead"> Essays, books, wiki on technologies, career, markets, and more. </p> </div> <div id="loading"> <div id="loading-image" class="lds-ellipsis"><div></div><div></div><div></div><div></div></div> </div> <script>$(window).on("load",function(){$("#loading").hide()});</script> <div class="main-content"> <div class="container"> <div class="row"> <div class="col-md-2 pl-0"> <div class="share sticky-top sticky-top-offset"> <p> Share </p> <ul> <li class="ml-1 mr-1"> <a target="_blank" href="https://twitter.com/intent/tweet?text=Layer-4 Load Balancer & Zero-downtime Autoscaling and Upgrade&url=charlesxu.io/source-ip-autoscale/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;"> <i class="fab fa-twitter"></i> </a> </li> <li class="ml-1 mr-1"> <a target="_blank" href="https://facebook.com/sharer.php?u=charlesxu.io/source-ip-autoscale/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;"> <i class="fab fa-facebook-f"></i> </a> </li> <li class="ml-1 mr-1"> <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=charlesxu.io/source-ip-autoscale/" onclick="window.open(this.href, 'width=550,height=435');return false;"> <i class="fab fa-linkedin-in"></i> </a> </li> </ul> <div class="sep"> </div> <ul> <li> <a class="small smoothscroll" href="#disqus_thread"></a> </li> </ul> </div> </div> <div class="col-md-8 flex-first flex-md-unordered"> <div class="mainheading"> <h1 class="posttitle">Layer-4 Load Balancer & Zero-downtime Autoscaling and Upgrade</h1> </div> <img class="featured-image img-fluid lazyimg" style="min-width: 100%" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=" data-src="/assets/images/source-ip-autoscale/cover2.jpeg" alt="Layer-4 Load Balancer & Zero-downtime Autoscaling and Upgrade"> <div class="article-post"> <div class="toc mt-4 mb-4 lead"> <h3 style="color: #9c9c9c">Table of Contents</h3> <ul> <li><a href="#abstract">Abstract</a></li> <li><a href="#background">Background</a> <ul> <li><a href="#layer-4-cloud-load-balancer">Layer-4 cloud load balancer</a></li> <li><a href="#externaltrafficpolicy-local">externalTrafficPolicy: Local</a></li> </ul> </li> <li><a href="#partial-downtime-during-upgrade-and-autoscale-in">Partial downtime during upgrade and autoscale-in</a> <ul> <li><a href="#why-is-there-some-downtime">Why is there some downtime</a></li> <li><a href="#why-is-the-downtime-partial">Why is the downtime partial</a></li> <li><a href="#why-host-networking">Why host networking</a></li> <li><a href="#how-much-downtime">How much downtime</a></li> </ul> </li> <li><a href="#solutions">Solutions</a> <ul> <li><a href="#use-pod-ips-as-lb-backends">Use Pod IPs as LB backends</a></li> <li><a href="#proxyterminatingendpoints">ProxyTerminatingEndpoints</a></li> <li><a href="#customize-nlb-keep-host-networking">Customize NLB, keep host networking</a></li> </ul> </li> </ul> </div> <h3 id="abstract">Abstract</h3> <p>Your Kubernetes cluster probably has a shared ingress for north-south traffic, coming from a cloud load balancer and lands on your favorite proxies like Envoy, or Istio gateways, or Nginx.</p> <p>If you</p> <ul> <li>use a LoadBalancer-type <code class="language-plaintext highlighter-rouge">Service</code> to create a Layer-4 Load Balancer fronting your Kubernetes ingress</li> <li>retain source IP address by setting <code class="language-plaintext highlighter-rouge">externalTrafficPolicy: Local</code></li> </ul> <p>Then horizontal autoscaling (scale-in) and rolling upgrade will incur some downtime for you.</p> <p>This post</p> <ul> <li>explains why there is partial disruption, and how much disruption to expect</li> <li>discusses several options to achieve zero downtime upgrade and autoscaling</li> </ul> <p>For simplicity, the rest of the doc assumes Envoy as the ingress gateway.</p> <h3 id="background">Background</h3> <h4 id="layer-4-cloud-load-balancer">Layer-4 cloud load balancer</h4> <p>The routing of traffic to Envoy is facilitated by a layer-4 (L4) cloud load balancer, known as Network Load Balancer (NLB) in AWS terminology. The <a href="https://github.com/kubernetes-sigs/aws-load-balancer-controller">aws-load-balancer-controller</a> provisions such load balancer (LB) by watching LoadBalancer-type Service objects in Kubernetes. Each Service object opens dedicated NodePort on all Nodes in selected Envoy node pools. Traffic to Envoy will first be routed to NodePort on the Node hosting Envoy Pod, then DNAT-ed (iptables) to the Pod on the same Node, as shown in the following diagram.</p> <div style="text-align: center"> <p><img src="/assets/images/source-ip-autoscale/1.png" width="680"/></p> </div> <p>(image <a href="https://kubernetes.io/blog/2022/12/30/advancements-in-kubernetes-traffic-engineering/#traffic-loss-from-load-balancers-during-rolling-updates">source</a>)</p> <p>The LB periodically check the HealthCheck NodePort. The HealthCheck NodePort will fail if</p> <ul> <li>the Node does not host any target Pods, or</li> <li>none of the target Pods on this Node is ready, determined by the Pod’s readiness probe</li> </ul> <h4 id="externaltrafficpolicy-local">externalTrafficPolicy: Local</h4> <p>Suppose the Kubernetes Service object is configured with <code class="language-plaintext highlighter-rouge">externalTrafficPolicy: Local</code>. Then, the kube-proxy directs packets exclusively to Envoy Pods residing on the same Node, even if there are other Nodes running Envoy. This setup has two benefits: one less hop (lower latency) and preserving source IP address (for allowlist or rate limiting).</p> <p>But <code class="language-plaintext highlighter-rouge">externalTrafficPolicy: Local</code> is problematic during rolling upgrades or scale-in. The reason is that traffic arriving at NodePort will be dropped by kube-proxy if node has no ready Envoy Pods. LB will keep forwarding traffic to this Node until LB detects the HealthCheck NodePort is failing. Then, LB will mark the Node as unhealthy.</p> <p>There is a certain delay between two key events in this setup:</p> <ul> <li>An Envoy Pod becoming NotReady (for example, if it enters the “Terminating” state during a rolling upgrade).</li> <li>The subsequent periodic health check carried out by the load balancer.</li> </ul> <p>During such delay, client traffic to this Node is blackholed.</p> <div style="text-align: center"> <p><img src="/assets/images/source-ip-autoscale/2.png" width="680"/></p> </div> <p>(image <a href="https://kubernetes.io/blog/2022/12/30/advancements-in-kubernetes-traffic-engineering/#traffic-loss-from-load-balancers-during-rolling-updates">source</a>)</p> <h3 id="partial-downtime-during-upgrade-and-autoscale-in">Partial downtime during upgrade and autoscale-in</h3> <h4 id="why-is-there-some-downtime">Why is there some downtime</h4> <p>As discussed in the previous section, client traffic to an Envoy Node is blackholed during the time between the envoy Pod on such Node enters the <code class="language-plaintext highlighter-rouge">Terminating</code> state and the LB performs the next health check. Kube-proxy will remove forwarding rules from NodePort to the Pod once the Pod enters the <code class="language-plaintext highlighter-rouge">Terminating</code> state. Kubernetes 1.24 and 1.25 considers the <code class="language-plaintext highlighter-rouge">Terminating</code> state as not ready.</p> <p>For the same reason, horizontal scale-in will also cause downtime. For a while, I was just running Envoy as a DaemonSet on a node pool that does not autoscale.</p> <h4 id="why-is-the-downtime-partial">Why is the downtime partial</h4> <p>This downtime only affects one Node at a time, because currently, Envoy DaemonSet has the following upgrade strategy:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>  <span class="na">updateStrategy</span><span class="pi">:</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">RollingUpdate</span>
    <span class="na">rollingUpdate</span><span class="pi">:</span>
      <span class="na">maxUnavailable</span><span class="pi">:</span> <span class="m">1</span>
      <span class="na">maxSurge</span><span class="pi">:</span> <span class="m">0</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>Thus, Kubernetes will terminate one Pod at a time, then create new Pod on the same Node. There are 6 Pods in each DaemonSet, so not all envoy Pods are down at the same time.</p> <p>The reason for <code class="language-plaintext highlighter-rouge">maxSurge: 0</code> is that envoy-ingress Pods run on host networking. It means we cannot have 2 envoy Pods running on the same Node, because they both bind to the same ports. Thus, the current update strategy is to kill a Pod, then start a new one.</p> <h4 id="why-host-networking">Why host networking</h4> <p>Running Envoy in host networking means traffic bypasses the Pod overlay network (Normally, each Pod runs in separate network namespaces). Thus, host networking reduces the overhead of network hops and encapsulation due to overlays. This results in lower latency and higher throughput.</p> <p>But how much performance gain exactly? It depends on many factors like hardware and bandwidth. Cilium did some <a href="https://cilium.io/blog/2021/05/11/cni-benchmark">benchmark</a>—take this marketing with a grain of salt—that suggests host networking could improve throughput by 20% and latency by 25%. They didn’t say how many iptables rules (which scale linearly) are on the given hosts.</p> <h4 id="how-much-downtime">How much downtime</h4> <p>After NLB detects in its target group an unhealthy instance, NLB will stop creating new connections to that target. However, existing connections are not immediately terminated until a default 300s of draining timeout, or <code class="language-plaintext highlighter-rouge">RST</code> by clients or Envoy. Thus, in the worst case, the blackhole period per Pod is 310 seconds.</p> <p>In practice, the startup time of a new Envoy Pod on the same Node will be shorter than 300s. NLB continues health-checking the unhealthy Node, and will mark the Node as healthy as gain once the new Pod is ready. But for the worst-case analysis, let’s assume the blackhole period per Node is 310 seconds.</p> <p>Given 6 Nodes, Envoy DaemonSet will exhibit a 16.7% error rate for a total of 310 * 6 seconds, which is 1860 seconds, or 31 minutes in the worst case.</p> <p>The 16.7% error rate comes from the fact that 1 of the 6 Pods are in the <code class="language-plaintext highlighter-rouge">Terminating</code> state. Still, 16.7% is an appropriation, because another downside of <code class="language-plaintext highlighter-rouge">externalTrafficPolicy: Local</code> is that connections may not distribute evenly, especially if there are long-running connections on the Terminating Pod. NLB does not support the least-connections load balancing scheme.</p> <h3 id="solutions">Solutions</h3> <h4 id="use-pod-ips-as-lb-backends">Use Pod IPs as LB backends</h4> <p>In this case, NLB sends traffic directly to the Pods selected by k8s Service. The benefits are:</p> <ul> <li>Eliminate the extra network hop (NodePort) through the worker Nodes</li> <li>Allow NLB to keep sending traffic to Pods in the <code class="language-plaintext highlighter-rouge">Terminating</code> state but mark the target as Draining</li> </ul> <p>AWS load balancer controller supports this feature natively with “NLB IP-mode”. On other cloud, you can implement such controller yourself, watching Pod events and reconcile with L4 LB target groups.</p> <p>To enable IP-mode, we just need to update the Service annotations</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="gd">-service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: instance
</span><span class="gi">+service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: ip
</span>
# Health check the Pods directly
<span class="gi">+service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol: http
+service.beta.kubernetes.io/aws-load-balancer-healthcheck-port: "9901"
+service.beta.kubernetes.io/aws-load-balancer-healthcheck-path: /ready
</span>
# NLB with IP targets by default does not pass the client source IP address,
<span class="err">#</span> unless we specifically configure the target group attributes.
<span class="gi">+service.beta.kubernetes.io/aws-load-balancer-target-group-attributes: preserve_client_ip.enabled=true
</span></pre></td></tr></tbody></table></code></pre></div></div> <p>To achieve zero-downtime upgrade, we need to additionally configure on the envoy Pod a <code class="language-plaintext highlighter-rouge">preStop</code> hook like below. When Pod enters the Terminating state, k8s will execute the <code class="language-plaintext highlighter-rouge">preStop</code> hook and keep the Pod in <code class="language-plaintext highlighter-rouge">Terminating</code> until the preS`top hook completes.</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="c1"># We must define a longer terminationGracePeriodSeconds, which by default</span>
<span class="c1"># is 30s, upon which the Pod is killed even if preStop has not completed.</span>
<span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">305</span>

<span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">envoy</span>
    <span class="na">lifecycle</span><span class="pi">:</span>
      <span class="na">preStop</span><span class="pi">:</span>
        <span class="na">exec</span><span class="pi">:</span>
          <span class="c1"># The default target group attribute</span>
          <span class="c1"># “deregistration_delay.timeout_seconds” is 300s, configurable</span>
          <span class="c1"># through Service annotation.</span>
          <span class="na">command</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">/bin/sh</span>
            <span class="pi">-</span> <span class="s">-c</span>
            <span class="pi">-</span> <span class="s">curl -X POST http://localhost:9901/healthcheck/fail &amp;&amp; sleep </span><span class="m">300</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>By failing the envoy health check but keeping envoy running in the <code class="language-plaintext highlighter-rouge">Terminating</code> state, envoy can still process traffic. Once NLB deems the Envoy Pod unhealthy, it halts new request routing to the Pod but maintains existing connections. Consequently, active TCP connections persist, with client requests continuing to the now-unhealthy NLB target (Envoy Pod) until either client or envoy closes the connection or idle timeout expiry, defaulting to 300 seconds for NLB.</p> <h4 id="proxyterminatingendpoints">ProxyTerminatingEndpoints</h4> <p><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/1669-proxy-terminating-endpoints/README.md">ProxyTerminatingEndpoints</a> is a new beta feature in Kubernetes version 1.26. It is enabled by default.</p> <p>When there is a rolling update and a Node only contains terminating Pods, kube-proxy will route traffic to the terminating Pods based on their readiness. At the same time, kube-proxy will actively fail the health check NodePort if there are only terminating Pods available. By doing so, kube-proxy alerts the external load balancer that new connections should not be sent to that Node but will gracefully handle requests for existing connections.</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="c1"># We must define a longer terminationGracePeriodSeconds, which by default</span>
<span class="c1"># is 30s, upon which the Pod is killed even if preStop has not completed.</span>
<span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">305</span>

<span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">envoy</span>
    <span class="na">lifecycle</span><span class="pi">:</span>
      <span class="na">preStop</span><span class="pi">:</span>
        <span class="na">exec</span><span class="pi">:</span>
          <span class="c1"># The default target group attribute</span>
          <span class="c1"># “deregistration_delay.timeout_seconds” is 300s, configurable</span>
          <span class="c1"># through Service annotation.</span>
          <span class="na">command</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">/bin/sh</span>
            <span class="pi">-</span> <span class="s">-c</span>
            <span class="pi">-</span> <span class="s">sleep </span><span class="m">300</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>Note that here we must NOT call <code class="language-plaintext highlighter-rouge">POST http://localhost:9901/healthcheck/fail</code> on Envoy, different from what NLB IP-mode needs. The reason is that <code class="language-plaintext highlighter-rouge">Terminating</code> Pods need to pass the readiness probe to continue receiving traffic, so we cannot fail the envoy health check. Since kube-proxy will actively fail the health check NodePort if there are only terminating Pods available on the Node, NLB will start the draining process.</p> <h4 id="customize-nlb-keep-host-networking">Customize NLB, keep host networking</h4> <p>Forget about the NodePort and HealthCheck NodePort opened by kube-proxy. We can create the NLB not through k8s Service object, but using infra-as-code tools such as pulumi. This bypasses the kube-proxy. The NLB will look like this</p> <table> <thead> <tr> <th style="text-align: left">NLB frontend port</th> <th style="text-align: left">Target port (=NodePort =Pod port because of host networking)</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">443</td> <td style="text-align: left">8443</td> </tr> <tr> <td style="text-align: left">80</td> <td style="text-align: left">8080</td> </tr> </tbody> </table> <p>The NLB will find all Nodes running envoy Pods using the autoscaling group for the envoy-ingress node pool. Yes, we can autoscale with solution 4.3. This setup is similar to Section 4.1.1 NLB IP-mode, except the NLB is not created by Kubernetes. We need the following Pod spec change.</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="c1"># We must define a longer terminationGracePeriodSeconds, which by default</span>
<span class="c1"># is 30s, upon which the Pod is killed even if preStop has not completed.</span>
<span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">305</span>

<span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">envoy</span>
    <span class="na">lifecycle</span><span class="pi">:</span>
      <span class="na">preStop</span><span class="pi">:</span>
        <span class="na">exec</span><span class="pi">:</span>
          <span class="c1"># The default target group attribute</span>
          <span class="c1"># “deregistration_delay.timeout_seconds” is 300s, configurable</span>
          <span class="c1"># through Service annotation.</span>
          <span class="na">command</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">/bin/sh</span>
            <span class="pi">-</span> <span class="s">-c</span>
            <span class="pi">-</span> <span class="s">curl -X POST http://localhost:9901/healthcheck/fail &amp;&amp; sleep </span><span class="m">300</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>We also need to expose the “/ready” endpoint from envoy to the host. Then, we need to update the Service annotations like the following.</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="err">#</span> Health check the Pods directly through NodePort 9901
<span class="gi">+service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol: http
+service.beta.kubernetes.io/aws-load-balancer-healthcheck-port: "9901"
+service.beta.kubernetes.io/aws-load-balancer-healthcheck-path: /ready
</span></pre></td></tr></tbody></table></code></pre></div></div> </div> <p> <small> <span class="post-date"><time class="post-date" datetime="2023-08-06">06 Aug 2023</time></span> </small> </p> <div class="after-post-cats"> <ul class="tags mb-4"> <li> <a class="smoothscroll" href="/categories#cloud">cloud</a> </li> <li> <a class="smoothscroll" href="/categories#kubernetes">kubernetes</a> </li> <li> <a class="smoothscroll" href="/categories#networking">networking</a> </li> </ul> </div> <div class="after-post-tags"> <ul class="tags"> </ul> </div> <div class="row PageNavigation d-flex justify-content-between font-weight-bold"> <a class="prev d-block col-md-6" href="/sales-lessons/"> &laquo; Enterprise Sales</a> <div class="clearfix"></div> </div> </div> </div> </div> </div> <div class="alertbar"> <div class="container text-center"> <span><img src="/assets/images/logo.png" alt="Charles Xu" height="32" width="32"> &nbsp; Never miss a <b>story</b> from me, subscribe to my newsletter</span> <form action="https://gmail.us5.list-manage.com/subscribe/post?u=b3d456844a3860642cd584c1b&amp;id=3f0c5c8bcd" method="post" name="mc-embedded-subscribe-form" class="wj-contact-form validate" target="_blank" novalidate> <div class="mc-field-group"> <input type="email" placeholder="Email" name="EMAIL" class="required email" id="mce-EMAIL" autocomplete="on" required> <input type="submit" value="Subscribe" name="subscribe" class="heart"> </div> </form> </div> </div> </div> <div class="jumbotron fortags"> <div class="d-md-flex h-100"> <div class="col-md-4 transpdark align-self-center text-center h-100"> <div class="d-md-flex align-items-center justify-content-center h-100"> <h2 class="d-md-block align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2> </div> </div> <div class="col-md-8 p-5 align-self-center text-center"> <a class="mt-1 mb-1" href="/categories#git">git (3)</a> <a class="mt-1 mb-1" href="/categories#web">web (6)</a> <a class="mt-1 mb-1" href="/categories#microservices">microservices (3)</a> <a class="mt-1 mb-1" href="/categories#distributed-systems">distributed systems (4)</a> <a class="mt-1 mb-1" href="/categories#signal-processing">signal processing (1)</a> <a class="mt-1 mb-1" href="/categories#istio">istio (3)</a> <a class="mt-1 mb-1" href="/categories#security">security (1)</a> <a class="mt-1 mb-1" href="/categories#docker">docker (2)</a> <a class="mt-1 mb-1" href="/categories#interview">interview (2)</a> <a class="mt-1 mb-1" href="/categories#kubernetes">kubernetes (6)</a> <a class="mt-1 mb-1" href="/categories#operation">operation (2)</a> <a class="mt-1 mb-1" href="/categories#networking">networking (4)</a> <a class="mt-1 mb-1" href="/categories#career">career (5)</a> <a class="mt-1 mb-1" href="/categories#go">go (1)</a> <a class="mt-1 mb-1" href="/categories#shell">shell (1)</a> <a class="mt-1 mb-1" href="/categories#investment">investment (1)</a> <a class="mt-1 mb-1" href="/categories#law">law (1)</a> <a class="mt-1 mb-1" href="/categories#startup">startup (4)</a> <a class="mt-1 mb-1" href="/categories#accounting">accounting (1)</a> <a class="mt-1 mb-1" href="/categories#oss">oss (1)</a> <a class="mt-1 mb-1" href="/categories#sales">sales (1)</a> <a class="mt-1 mb-1" href="/categories#advice">advice (1)</a> <a class="mt-1 mb-1" href="/categories#cloud">cloud (1)</a> </div> </div> </div> <footer class="footer"> <div class="container"> <div class="row"> <div class="col-md-6 col-sm-6 text-center text-lg-left" style="margin-bottom: 10px;"> Copyright © 2016-2023 Charles Xu </div> </div> </div> </footer> </div> <script src="/assets/js/popper.min.js"></script> <script src="/assets/js/bootstrap.min.js"></script> <script src="/assets/js/mediumish.js"></script> <script src="/assets/js/lazyload.js"></script> <script src="/assets/js/ie10-viewport-bug-workaround.js"></script> <link href="/assets/css/screen.css" rel="stylesheet"> <link href="/assets/css/main.css" rel="stylesheet"> </body> </html>